package com.moviesAPI.moviesAPI.controllers;


import com.moviesAPI.moviesAPI.entities.Character;
import com.moviesAPI.moviesAPI.entities.Genre;
import com.moviesAPI.moviesAPI.entities.Movie;
import com.moviesAPI.moviesAPI.repositories.CharacterRepository;
import com.moviesAPI.moviesAPI.repositories.GenreRepository;
import com.moviesAPI.moviesAPI.repositories.MovieRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Description;
import org.springframework.stereotype.Controller;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;

@Controller // This means that this class is a Controller
@Validated
@RequestMapping(path="/movies") // This means URL's start with /movies (after Application path)
public class MovieController {
    @Autowired // This means to get the bean called movieRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private MovieRepository movieRepository;
    @Autowired
    private CharacterRepository characterRepository;
    @Autowired
    private GenreRepository genreRepository;

    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewMovie (@RequestParam String title,
                                                 @RequestParam String date,
                                                 @RequestParam Integer rating,
                                                 @RequestParam(required = false) List<Long> genresIds,
                                                 @RequestParam(required = false) List<Long> charactersIds/*,
                                                 @RequestParam MultipartFile multipartImage*/) throws IOException {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        Movie movie = new Movie();
        movie.setTitle(title);
        movie.setRating(rating);
        movie.setDate(date);
        //movie.setImage(multipartImage.getBytes());

        //only previously added characters will be added to movie
        if (charactersIds != null) {
            for (Long characterId : charactersIds) {
                Optional<Character> characters = characterRepository.findById(characterId);
                if (characters.isPresent()) {
                    Character character = characters.get();
                    character.getMovies().add(movie);
                    //movie.getCharacters().add(character);
                    //characterRepository.save(character);
                }
            }
        }
        //only previously added genres will be added to movie
        if (genresIds != null) {
            for (Long genreId : genresIds) {
                Optional<Genre> genres = genreRepository.findById(genreId);
                if (genres.isPresent()) {
                    Genre genre = genres.get();
                    genre.getMovies().add(movie);
                    //movie.getGenres().add(genre);
                    //genreRepository.save(genre);
                }
            }
        }
        movieRepository.save(movie);
        return title+ " Saved";
    }

    @PostMapping(path="/edit")
    @Description("Edits any movie's field. editing characters/genres removes the previously saved characters/genres!")
    public @ResponseBody String editMovie (@RequestParam Long id, @RequestParam(required = false) String title,
                                               @RequestParam(required = false) String date,
                                               @RequestParam(required = false) Integer rating,
                                               @RequestParam(required = false) List<Long> charactersIds,
                                               @RequestParam(required = false) List<Long> genresIds/*,
                                               @RequestParam(required = false) MultipartFile multipartImage*/) throws IOException {
        Optional<Movie> movies = movieRepository.findById(id);
        if (!movies.isPresent()) {
            return "Movie doesn't exist!";
        }
        Movie movie = movies.get();
        if (title != null) {
            movie.setTitle(title);
        }
        if (date != null) {
            movie.setDate(date);
        }
        if (rating != null) {
            movie.setRating(rating);
        }

        if (charactersIds != null) {
            movie.setCharacters(new HashSet<>());  //removes previously added characters!
            for(Long characterId : charactersIds){
                Optional<Character> characters = characterRepository.findById(characterId);
                if (characters.isPresent()) {
                    Character character = characters.get();
                    character.getMovies().add(movie);
                    movie.getCharacters().add(character);
                    characterRepository.save(character);
                }
            }
        }
        if (genresIds != null) {
            movie.setCharacters(new HashSet<>());  //removes previously added genres!
            for(Long genreId : genresIds){
                Optional<Genre> genres = genreRepository.findById(genreId);
                if (genres.isPresent()) {
                    Genre genre = genres.get();
                    genre.getMovies().add(movie);
                    movie.getGenres().add(genre);
                    genreRepository.save(genre);
                }
            }
        }
        movieRepository.save(movie);
        return title + " Updated!";
    }

    @DeleteMapping(path="/delete")
    public @ResponseBody String deleteMovie(@RequestParam Long id) {
        Optional<Movie> movies = movieRepository.findById(id);
        if (!movies.isPresent()) {
            return "movie not found!";
        }
        movieRepository.delete(movies.get());
        return id +" deleted!";
    }

    @GetMapping(path= "/detail")
    public @ResponseBody Movie getMovieDetail(@RequestParam Long id) {
        Optional<Movie> movies = movieRepository.findById(id);
        if (movies.isPresent()) {
            return movies.get();
        }
        return null;
    }

    @RequestMapping(method = RequestMethod.GET)
    public @ResponseBody
    Object filterBy(@RequestParam(value = "title",required = false) String title,
                    @RequestParam(value = "genreId",required = false) Long genreId,
                    @RequestParam(value = "orderBy",required = false) String orderBy) {

        if (title != null) {
            return movieRepository.findByTitle(title);
        }

        if (genreId != null) {
            Optional<Genre> genres  = genreRepository.findById(genreId);
            if (genres.isPresent()){
                return genres.get().getMovies();
            }
        }
        if (orderBy != null) {
            if (orderBy.equals("ASC")) {
                return movieRepository.findByOrderByDateAsc();
            } else {
                if (orderBy.equals("DESC")) {
                    return movieRepository.findByOrderByDateDesc();
                }
            }
        }
        return movieRepository.findBy(); //returns all movies in list view if no params were given
    }

}