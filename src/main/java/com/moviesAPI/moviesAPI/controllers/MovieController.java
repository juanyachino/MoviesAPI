package com.moviesAPI.moviesAPI.controllers;


import com.moviesAPI.moviesAPI.entities.Character;
import com.moviesAPI.moviesAPI.entities.Genre;
import com.moviesAPI.moviesAPI.entities.Movie;
import com.moviesAPI.moviesAPI.repositories.CharacterRepository;
import com.moviesAPI.moviesAPI.repositories.GenreRepository;
import com.moviesAPI.moviesAPI.repositories.MovieRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Description;
import org.springframework.stereotype.Controller;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;

@Controller // This means that this class is a Controller
@Validated
@RequestMapping(path="/movies") // This means URL's start with /movies (after Application path)
public class MovieController {
    @Autowired // This means to get the bean called movieRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private MovieRepository movieRepository;
    @Autowired
    private CharacterRepository characterRepository;
    @Autowired
    private GenreRepository genreRepository;

    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewMovie (@RequestParam String title,
                                                 @RequestParam String date,
                                                 @RequestParam Integer rating,
                                                 @RequestParam List<String> genresNames,
                                                 @RequestParam List<String> charactersNames/*,
                                                 @RequestParam MultipartFile multipartImage*/) throws IOException {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        Movie movie = new Movie();
        movie.setTitle(title);
        movie.setRating(rating);
        movie.setDate(date);
        //movie.setImage(multipartImage.getBytes());

        //only previously added characters will be added to movie
        for(String characterName : charactersNames){
            List<Character> characters = characterRepository.findByName(characterName);
            if (!characters.isEmpty()) {
                Character character = characters.get(0);
                character.getMovies().add(movie);
                movie.getCharacters().add(character);
            }
        }
        for(String genreName : genresNames){
            List<Genre> genres = genreRepository.findByName(genreName);
            if (!genres.isEmpty()) {
                Genre genre = genres.get(0);
                genre.getMovies().add(movie);
                movie.getGenres().add(genre);
            }
        }
        movieRepository.save(movie);
        return title+ " Saved";
    }

    @PostMapping(path="/edit")
    @Description("Edits any movie's field. editing characters/genres removes the previously saved characters/genres!")
    public @ResponseBody String editMovie (@RequestParam String title,
                                               @RequestParam(required = false) String date,
                                               @RequestParam(required = false) Integer rating,
                                               @RequestParam(required = false) List<String> charactersNames,
                                               @RequestParam(required = false) List<String> genresNames/*,
                                                 @RequestParam(required = false) MultipartFile multipartImage*/) throws IOException {
        List<Movie> movies = movieRepository.findByTitle(title);
        if (movies.isEmpty()) {
            return "Movie doesn't exist!";
        }
        Movie movie = movies.get(0);
        if (date != null) {
            movie.setDate(date);
        }
        if (rating != null) {
            movie.setRating(rating);
        }

        if (charactersNames != null) {
            movie.setCharacters(new HashSet<>());  //removes previously added characters!
            for(String characterName : charactersNames){
                List<Character> characters = characterRepository.findByName(characterName);
                if (!characters.isEmpty()) {
                    Character character = characters.get(0);
                    character.getMovies().add(movie);
                    movie.getCharacters().add(character);
                }
            }
        }
        if (genresNames != null) {
            movie.setCharacters(new HashSet<>());  //removes previously added genres!
            for(String genreName : genresNames){
                List<Genre> genres = genreRepository.findByName(genreName);
                if (!genres.isEmpty()) {
                    Genre genre = genres.get(0);
                    genre.getMovies().add(movie);
                    movie.getGenres().add(genre);
                }
            }
        }
        movieRepository.save(movie);
        return "Updated!";
    }

    @DeleteMapping(path="/delete")
    public @ResponseBody String deleteMovie(@RequestParam String title) {
        List<Movie> movies = movieRepository.findByTitle(title);
        if (movies.isEmpty()) {
            return "movie not found!";
        }
        movieRepository.delete(movies.get(0));
        return title +" deleted!";
    }

    @GetMapping(path= "/detail")
    public @ResponseBody Movie getMovieDetail(@RequestParam String title) {
        List<Movie> movies = movieRepository.findByTitle(title);
        if (movies.isEmpty()) {
            return null;
        }
        return movies.get(0);
    }

    @RequestMapping(method = RequestMethod.GET)
    public @ResponseBody
    Object filterBy(@RequestParam(value = "title",required = false) String title,
                    @RequestParam(value = "genreId",required = false) Long genreId,
                    @RequestParam(value = "orderBy",required = false) String orderBy) {

        if (title != null) {
            return movieRepository.findByTitle(title);
        }

        if (genreId != null) {
            Optional<Genre> genres  = genreRepository.findById(genreId);
            if (genres.isPresent()){
                return genres.get().getMovies();
            }
        }
        if (orderBy != null) {
            if (orderBy.equals("ASC")) {
                return movieRepository.findByOrderByDateAsc();
            } else {
                if (orderBy.equals("DESC")) {
                    return movieRepository.findByOrderByDateDesc();
                }
            }
        }
        return movieRepository.findBy(); //returns all movies in list view if no params were given
    }

}