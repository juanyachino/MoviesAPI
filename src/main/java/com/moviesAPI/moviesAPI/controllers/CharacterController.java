package com.moviesAPI.moviesAPI.controllers;




import com.moviesAPI.moviesAPI.entities.Character;
import com.moviesAPI.moviesAPI.entities.Movie;
import com.moviesAPI.moviesAPI.repositories.CharacterRepository;
import com.moviesAPI.moviesAPI.repositories.MovieRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Description;
import org.springframework.stereotype.Controller;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.*;

@Controller // This means that this class is a Controller
@Validated
@RequestMapping(path="/characters") // This means URL's start with /characters (after Application path)
public class CharacterController {
    @Autowired // This means to get the bean called characterRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private CharacterRepository characterRepository;
    @Autowired
    private MovieRepository movieRepository;

    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewCharacter (@RequestParam String name,
                                                 @RequestParam String story,
                                                 @RequestParam Integer age,
                                                 @RequestParam Integer weight,
                                                 @RequestParam(required = false) List<Long> moviesIds /*,
                                                 @RequestParam MultipartFile multipartImage*/) throws IOException {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        Character character = new Character();
        character.setName(name);
        character.setAge(age);
        character.setStory(story);
        character.setWeight(weight);
        //only previously added movies will be added to character
        for(Long movieId : moviesIds){
            Optional<Movie> movies = movieRepository.findById(movieId);
            if (movies.isPresent()) {
                Movie movie = movies.get();
                character.getMovies().add(movie);
                movie.getCharacters().add(character);
            }
        }
       // character.setImage(multipartImage.getBytes());
        characterRepository.save(character);
        return "Saved";
    }
    @PostMapping(path="/edit")
    @Description("Edits any character's field. editing movies removes the previously saved movies!")
    public @ResponseBody String editCharacter (@RequestParam Long id,
                                               @RequestParam(required = false) String name,
                                                 @RequestParam(required = false) String story,
                                                 @RequestParam(required = false) Integer age,
                                                 @RequestParam(required = false) Integer weight,
                                                 @RequestParam(required = false) List<Long> moviesIds /*,
                                                 @RequestParam(required = false) MultipartFile multipartImage*/) throws IOException {
        Optional<Character> characters = characterRepository.findById(id);
        if (!characters.isPresent()) {
            return "Character doesn't exist!";
        }
        Character character = characters.get();
        if (name != null) {
            character.setName(name);
        }
        if (story != null) {
            character.setStory(story);
        }
        if (age != null) {
            character.setAge(age);
        }
        if (weight != null) {
            character.setWeight(weight);
        }
        if (moviesIds != null) {
            character.setMovies(new HashSet<>());  //removes previously added movies!
            for(Long movieId : moviesIds){
                Optional<Movie> movies = movieRepository.findById(movieId);
                if (movies.isPresent()) {
                    Movie movie = movies.get();
                    character.getMovies().add(movie);
                    movie.getCharacters().add(character);
                }
            }
        }
        characterRepository.save(character);
        return "Updated!";
    }
    @DeleteMapping(path="/delete")
    public @ResponseBody String deleteCharacter(@RequestParam Long id) {
        Optional<Character> character = characterRepository.findById(id);
        if (!character.isPresent()) {
            return "character not found";
        }
        characterRepository.delete(character.get());
        return "deleted!";
    }
    @GetMapping(path= "/detail")
    public @ResponseBody Character getCharacterDetail(@RequestParam Long id) {
        Optional<Character> character = characterRepository.findById(id);
        if (character.isPresent()) {
            return null;
        }
        return character.get();
    }

    @RequestMapping(method = RequestMethod.GET)
    public @ResponseBody
    Object filterBy(@RequestParam(value = "age",required = false) Integer age,
                    @RequestParam(value = "name",required = false) String name,
                    @RequestParam(value = "weight",required = false) Integer weight,
                    @RequestParam(value = "movieId",required = false) Long movieId) {
        if (age != null) {
            return characterRepository.findByAge(age);
        }
        if (name != null) {
            return characterRepository.findByName(name);
        }
        if (weight != null) {
            return characterRepository.findByWeight(weight);
        }
        if (movieId != null) {
            Optional<Movie> movies = movieRepository.findById(movieId);
            if (movies.isPresent()){
                return movies.get().getCharacters();
            }
        }
        return characterRepository.findBy(); //returns all characters in list view if no params were given
    }
}